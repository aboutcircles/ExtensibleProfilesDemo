<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Circles Marketplace Viewer</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif; margin: 0; padding: 0; background: #fafafa; color: #222; }
    header { background: #2f3d4a; color: white; padding: 12px 16px; }
    main { padding: 16px; max-width: 1000px; margin: 0 auto; }
    .panel { background: white; border: 1px solid #ddd; border-radius: 6px; padding: 12px; margin-bottom: 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    label { display: inline-block; font-size: 12px; color: #444; margin-bottom: 4px; }
    input, select { padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; }
    input[type="text"] { width: 320px; max-width: 100%; }
    button { padding: 8px 14px; background: #2f7ae5; color: white; border: none; border-radius: 4px; cursor: pointer; }
    button:disabled { opacity: .6; cursor: default; }
    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 12px; }
    .card { background: white; border: 1px solid #e2e2e2; border-radius: 8px; overflow: hidden; display: flex; flex-direction: column; }
    .thumb { width: 100%; height: 180px; background: #f0f0f0; display: flex; align-items: center; justify-content: center; color: #888; font-size: 12px; object-fit: cover; }
    .card-body { padding: 10px 12px; display: flex; flex-direction: column; gap: 6px; }
    .muted { color: #666; font-size: 12px; }
    .error { color: #b00020; white-space: pre-wrap; }
    .small { font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    footer { text-align: center; color: #777; padding: 20px; font-size: 12px; }
    .inline { display:inline-block; }
  </style>
</head>
<body>
  <header>
    <h1 class="small">Circles Profile Market Viewer</h1>
  </header>
  <main>
    <section class="panel">
      <div class="row">
        <div>
          <label for="cid">Profile CID</label><br />
          <input id="cid" type="text" placeholder="Qm..." />
        </div>
        <div>
          <label for="ns">Dapp Namespace</label><br />
          <input id="ns" type="text" placeholder="e.g. market, alice, bob..." />
        </div>
        <div>
          <label for="gw">IPFS Gateway</label><br />
          <input id="gw" type="text" value="https://ipfs.io" />
        </div>
        <div style="align-self: end; padding-bottom: 2px;">
          <button id="loadBtn">Load</button>
        </div>
      </div>
      <div id="status" class="muted" style="margin-top: 8px;"></div>
      <div id="error" class="error" style="margin-top: 8px;"></div>
    </section>

    <section class="panel">
      <div class="row" style="justify-content: space-between;">
        <div>
          <strong>Products</strong> <span id="count" class="muted"></span>
        </div>
        <div class="muted small">One offer per product (first offer shown)</div>
      </div>
      <div id="results" class="grid" style="margin-top: 12px;"></div>
    </section>

    <details class="panel">
      <summary class="small">Help</summary>
      <div class="small" style="margin-top:8px;">
        • Enter a Profile CID and a Dapp Namespace. The page will fetch the profile from the IPFS gateway,<br />
        resolve the namespace index, and traverse the namespace chunks to find logical names like <span class="mono">product/&lt;sku&gt;</span>.<br />
        • For each product, its JSON is fetched and the first offer (if any) is displayed.<br />
        • Gateways commonly used: ipfs.io, cloudflare-ipfs.com, dweb.link
      </div>
    </details>
  </main>
  <footer>
    Static viewer bundled with Circles.Profiles.Tool — no wallet or signer needed.
  </footer>

<script>
(function(){
  const $ = sel => document.querySelector(sel);
  const cidInput = $('#cid');
  const nsInput = $('#ns');
  const gwInput = $('#gw');
  const statusEl = $('#status');
  const errorEl = $('#error');
  const resultsEl = $('#results');
  const countEl = $('#count');
  const loadBtn = $('#loadBtn');

  function setStatus(msg) { statusEl.textContent = msg || ''; }
  function setError(msg) { errorEl.textContent = msg || ''; }

  function gwUrl(path) {
    let gw = gwInput.value.trim().replace(/\/$/, '');
    if (!gw.startsWith('http')) gw = 'https://' + gw;
    return gw + path;
  }

  async function getJson(cid) {
    const url = gwUrl('/ipfs/' + encodeURIComponent(cid));
    const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
    if (!res.ok) throw new Error('Failed to fetch ' + url + ' — ' + res.status + ' ' + res.statusText);
    return res.json();
  }

  function ensureArray(v) { return Array.isArray(v) ? v : (v == null ? [] : [v]); }

  // Small concurrency-limited mapper
  async function mapLimit(items, limit, mapper) {
    const results = new Array(items.length);
    let nextIndex = 0;
    async function worker() {
      while (true) {
        const i = nextIndex++;
        if (i >= items.length) return;
        try { results[i] = await mapper(items[i], i); }
        catch (e) { results[i] = { __error: e }; }
      }
    }
    const workers = Array.from({ length: Math.min(limit, items.length) }, () => worker());
    await Promise.all(workers);
    return results;
  }

  function pickImageUrl(product) {
    const imgs = product?.image || [];
    if (!Array.isArray(imgs)) return null;
    for (const it of imgs) {
      if (!it) continue;
      if (typeof it === 'string') return it;
      if (typeof it?.url === 'string') return it.url;
      if (typeof it?.Url === 'string') return it.Url; // in case of C#-like JSON
      if (typeof it?.object?.contentUrl === 'string') return it.object.contentUrl;
      if (typeof it?.Object?.ContentUrl === 'string') return it.Object.ContentUrl;
    }
    return null;
  }

  function render(products) {
    resultsEl.innerHTML = '';
    countEl.textContent = products.length ? `(${products.length})` : '';
    for (const p of products) {
      const card = document.createElement('div');
      card.className = 'card';

      const imgUrl = pickImageUrl(p.product) || p.product?.imageUrl || p.product?.ImageUrl || null;
      const thumb = document.createElement(imgUrl ? 'img' : 'div');
      thumb.className = 'thumb';
      if (imgUrl) {
        thumb.src = imgUrl;
        thumb.loading = 'lazy';
        thumb.alt = p.product?.name || p.product?.Name || 'product-image';
      } else {
        thumb.textContent = 'No image';
      }

      const body = document.createElement('div');
      body.className = 'card-body';

      const name = p.product?.name || p.product?.Name || '(no name)';
      const h = document.createElement('div');
      h.textContent = name;
      h.style.fontWeight = '600';
      body.appendChild(h);

      if (p.product?.description || p.product?.Description) {
        const d = document.createElement('div');
        d.className = 'muted small';
        d.textContent = p.product.description || p.product.Description;
        body.appendChild(d);
      }

      const offer = p.offer;
      if (offer) {
        const price = offer.price || offer.Price;
        const curr = offer.priceCurrency || offer.PriceCurrency;
        const avail = offer.availability || offer.Availability;
        const availText = typeof avail === 'string' ? avail : (avail?.name || avail?.Name || '');
        const o = document.createElement('div');
        o.className = 'small';
        o.textContent = `Offer: ${price ?? '?'} ${curr ?? ''} ${availText ? '(' + availText + ')' : ''}`;
        body.appendChild(o);
      }

      const links = document.createElement('div');
      links.className = 'row';
      links.style.justifyContent = 'space-between';

      // Left side: Buy button (if offer.checkout present)
      const left = document.createElement('div');
      left.className = 'inline';
      if (offer) {
        const checkout = offer.checkout || offer.Checkout;
        if (typeof checkout === 'string' && checkout.trim() !== '') {
          const buyBtn = document.createElement('button');
          buyBtn.textContent = 'Buy';
          buyBtn.title = 'Open checkout';
          buyBtn.addEventListener('click', (ev) => {
            ev.preventDefault();
            try { window.open(checkout, '_blank', 'noopener'); } catch { location.href = checkout; }
          });
          left.appendChild(buyBtn);
        }
      }
      links.appendChild(left);

      // Right side: auxiliary links
      const right = document.createElement('div');
      right.className = 'inline';

      if (p.product?.url || p.product?.Url) {
        const a = document.createElement('a');
        a.href = p.product.url || p.product.Url;
        a.target = '_blank';
        a.rel = 'noopener';
        a.className = 'small inline';
        a.textContent = 'Open product page';
        right.appendChild(a);
        const sep = document.createElement('span'); sep.textContent = ' \u00A0·\u00A0 '; right.appendChild(sep);
      }

      const raw = document.createElement('a');
      raw.href = gwUrl('/ipfs/' + encodeURIComponent(p.cid));
      raw.target = '_blank';
      raw.rel = 'noopener';
      raw.className = 'small inline';
      raw.textContent = 'Raw JSON';
      right.appendChild(raw);

      links.appendChild(right);

      body.appendChild(links);
      card.appendChild(thumb);
      card.appendChild(body);
      resultsEl.appendChild(card);
    }
  }

  async function load() {
    setError('');
    setStatus('Loading...');
    resultsEl.innerHTML = '';
    countEl.textContent = '';

    const profileCid = cidInput.value.trim();
    const ns = nsInput.value.trim().toLowerCase();
    if (!profileCid || !ns) { setError('Please enter both Profile CID and Namespace.'); setStatus(''); return; }

    try {
      // 1) Load profile
      const profile = await getJson(profileCid);
      const namespaces = profile?.namespaces || profile?.Namespaces;
      if (!namespaces || typeof namespaces !== 'object') throw new Error('Profile has no namespaces table.');
      const indexCid = namespaces[ns];
      if (!indexCid) throw new Error(`Namespace not found in profile: ${ns}`);

      // 2) Load NameIndexDoc
      const indexDoc = await getJson(indexCid);
      const head = indexDoc?.head || indexDoc?.Head;
      if (!head) { setStatus('No entries for this namespace.'); render([]); return; }

      // 3) Traverse chunks from newest to oldest; keep newest per logical name
      const latest = new Map(); // name -> { link, chunkOrder, linkOrder }
      let cur = head;
      let chunkNumber = 0;
      while (cur) {
        const chunk = await getJson(cur);
        const links = chunk?.links || chunk?.Links || [];
        // Iterate newest-to-oldest within a chunk: assume append order
        for (let i = links.length - 1; i >= 0; i--) {
          const l = links[i] || {};
          const name = l.name || l.Name || '';
          const cid = l.cid || l.Cid || '';
          if (!name || !cid) continue;
          if (!name.toLowerCase().startsWith('product/')) continue;
          if (!latest.has(name)) {
            latest.set(name, { link: l, cid, name, chunkNumber, linkIndex: i });
          }
        }
        const prev = chunk?.prev || chunk?.Prev;
        if (!prev) break;
        cur = prev;
        chunkNumber++;
      }

      // 4) Fetch each product JSON and pick first offer — in parallel (with a safe concurrency limit)
      const latestArr = Array.from(latest.values());
      const concurrency = Math.min(8, Math.max(2, navigator.hardwareConcurrency || 4));
      const mapped = await mapLimit(latestArr, concurrency, async (entry) => {
        const { name, cid } = entry;
        try {
          const product = await getJson(cid);
          const offers = product?.offers || product?.Offers || [];
          const offer = Array.isArray(offers) ? (offers[0] || null) : (offers || null);
          return { name, cid, product, offer };
        } catch (e) {
          console.warn('Failed to load product', name, cid, e);
          return null;
        }
      });
      const items = mapped.filter(Boolean);

      // 5) Stable sort by product name
      items.sort((a, b) => {
        const an = (a.product?.name || a.product?.Name || a.name || '').toLowerCase();
        const bn = (b.product?.name || b.product?.Name || b.name || '').toLowerCase();
        return an.localeCompare(bn);
      });

      render(items);
      setStatus(`Loaded ${items.length} product(s).`);
    } catch (err) {
      console.error(err);
      setError(String(err?.message || err));
      setStatus('');
    }
  }

  loadBtn.addEventListener('click', () => { loadBtn.disabled = true; load().finally(() => loadBtn.disabled = false); });

  // Allow deep-linking via URL params ?cid=...&ns=...&gw=...
  const params = new URLSearchParams(location.search);
  const urlCid = params.get('cid');
  const urlNs = params.get('ns') || params.get('namespace');
  const urlGw = params.get('gw') || params.get('gateway');
  if (urlCid) cidInput.value = urlCid;
  if (urlNs) nsInput.value = urlNs;
  if (urlGw) gwInput.value = urlGw;

  if (urlCid && urlNs) {
    setTimeout(() => loadBtn.click(), 50);
  }
})();
</script>
</body>
</html>
